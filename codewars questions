Description:Write a method detect_int that returns the first positive integer for which an arbitrary number of lambdas returns true. If no arguments are passed in, then detect_int should return 1.For example:lam1 = lambda { |x| x > 9 }lam2 = lambda { |x| x**0.5 % 1 == 0 }detect_int  # => 1detect_int lam1  # => 10detect_int lam2  # => 1detect_int lam1, lam2  # => 16The testing rubric will never ask for a number that does not exist, e.g., detect_int(lambda { |x| x.odd? }, lambda { |x| x.even? }).Note that loops constructed using the loop { block } syntax are limited to 5000 iterations, but solutions will not be constrained to integers less than 5000.def detect_int(lam)i=0while i<20  if lam[i] == true    break  else  i+=1  endendienddef detect_int(*lam)i=0while i<100  taray=[]  for g in lam    taray<<g[i]  end  if taray.all?    return i  end  i+=1endendfinal sol ---def detect_int(*lam)i=1while lam.map { |e| e[i]==true }.all? == false  i+=1endiend--------------------------------Description:Dave has a lot of data he is required to apply filters to, which are simple enough, but he wants a shorter way of doing so.He wants the following functions to work as expected:even # [1,2,3,4,5].even should return [2,4]odd # [1,2,3,4,5].odd should return [1,3,5]under # [1,2,3,4,5].under(4) should return [1,2,3]over # [1,2,3,4,5].over(4) should return [5]in_range # [1,2,3,4,5].in_range(1..3) should return [1,2,3]They should also work when used together, for example:(1..100).to_a.even.in_range(18..30) # should return [18, 20, 22, 24, 26, 28, 30]And finally the filters should only accept integer values from an array, for example:["a", 1, "b", 300, "x", "q", 63, 122, 181, "z", 0.83, 0.11].even # should return [300, 122]